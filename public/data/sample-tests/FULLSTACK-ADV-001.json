{
    "id": "FULLSTACK-ADV-001",
    "title": "# Advanced Full Stack Development\n## Architecture, Performance, and Modern Frameworks",
    "time_limit": 300,
    "questions": [
      {
        "id": "q1",
        "question": "# Micro-frontend Architecture\n\nExamine this modern micro-frontend architecture diagram:\n\n![Micro-frontend Architecture](https://micro-frontends.org/ressources/diagrams/organisational/verticals-headline.png)\n\n1. Explain the concept of micro-frontends and how they differ from monolithic frontends\n2. Design a micro-frontend architecture for a large e-commerce platform with these requirements:\n   - Multiple teams need to work independently\n   - Some common UI components must be shared\n   - Must support different technology stacks\n   - Seamless user experience required\n3. How would you handle these challenges:\n   - Consistent styling and theming\n   - Shared state management\n   - Performance optimization\n   - Cross-team coordination\n4. Compare different implementation strategies (iframes, JavaScript integration, Web Components, Module Federation)\n5. Discuss deployment strategies for this architecture"
      },
      {
        "id": "q2",
        "question": "# React Performance Optimization\n\nAnalyze this React component that's experiencing performance issues:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst ProductList = ({ category }) => {\n  const [products, setProducts] = useState([]);\n  const [filteredProducts, setFilteredProducts] = useState([]);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [sortBy, setSortBy] = useState('price');\n  \n  useEffect(() => {\n    const fetchProducts = async () => {\n      const response = await fetch(`/api/products?category=${category}`);\n      const data = await response.json();\n      setProducts(data);\n    };\n    \n    fetchProducts();\n  }, [category]);\n  \n  useEffect(() => {\n    // Filter products based on search term\n    const results = products.filter(product =>\n      product.name.toLowerCase().includes(searchTerm.toLowerCase())\n    );\n    \n    // Sort filtered products\n    const sorted = [...results].sort((a, b) => {\n      if (sortBy === 'price') {\n        return a.price - b.price;\n      } else if (sortBy === 'name') {\n        return a.name.localeCompare(b.name);\n      } else {\n        return a.popularity - b.popularity;\n      }\n    });\n    \n    setFilteredProducts(sorted);\n  }, [products, searchTerm, sortBy]);\n  \n  const handleSearch = (event) => {\n    setSearchTerm(event.target.value);\n  };\n  \n  const handleSortChange = (event) => {\n    setSortBy(event.target.value);\n  };\n  \n  return (\n    <div>\n      <div className=\"controls\">\n        <input \n          type=\"text\" \n          placeholder=\"Search products...\" \n          value={searchTerm} \n          onChange={handleSearch} \n        />\n        \n        <select value={sortBy} onChange={handleSortChange}>\n          <option value=\"price\">Price</option>\n          <option value=\"name\">Name</option>\n          <option value=\"popularity\">Popularity</option>\n        </select>\n      </div>\n      \n      <div className=\"product-grid\">\n        {filteredProducts.map(product => (\n          <div key={product.id} className=\"product-card\">\n            <img src={product.image} alt={product.name} />\n            <h3>{product.name}</h3>\n            <p>${product.price.toFixed(2)}</p>\n            <button onClick={() => console.log(`Added ${product.name} to cart`)}>\n              Add to Cart\n            </button>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default ProductList;\n```\n\n1. Identify performance issues in this component\n2. Implement optimizations using React's performance features:\n   - Memoization\n   - Code splitting\n   - Virtualization for long lists\n   - Optimized re-renders\n3. Refactor the component structure for better performance\n4. How would you measure the actual performance impact of your changes?\n5. Discuss other React performance optimization techniques not applicable to this specific example"
      },
      {
        "id": "q3",
        "question": "# Advanced API Design Patterns\n\nConsider these API design patterns and their implementation:\n\n![API Gateway Pattern](https://microservices.io/i/apigateway.jpg)\n\n```javascript\n// GraphQL Schema\nconst typeDefs = gql`\n  type User {\n    id: ID!\n    name: String!\n    email: String!\n    orders: [Order!]\n  }\n  \n  type Product {\n    id: ID!\n    name: String!\n    price: Float!\n    description: String\n    inventory: Int!\n  }\n  \n  type OrderItem {\n    product: Product!\n    quantity: Int!\n  }\n  \n  type Order {\n    id: ID!\n    user: User!\n    items: [OrderItem!]!\n    total: Float!\n    status: OrderStatus!\n    createdAt: String!\n  }\n  \n  enum OrderStatus {\n    PENDING\n    PROCESSING\n    SHIPPED\n    DELIVERED\n    CANCELLED\n  }\n  \n  type Query {\n    user(id: ID!): User\n    product(id: ID!): Product\n    products(category: String, search: String): [Product!]!\n    order(id: ID!): Order\n  }\n  \n  type Mutation {\n    createOrder(userId: ID!, items: [OrderItemInput!]!): Order\n    updateOrderStatus(id: ID!, status: OrderStatus!): Order\n  }\n  \n  input OrderItemInput {\n    productId: ID!\n    quantity: Int!\n  }\n`;\n```\n\n1. Compare RESTful APIs, GraphQL, and gRPC - explain their advantages and use cases\n2. Analyze the GraphQL schema above and explain:\n   - Type relationships\n   - Query and mutation capabilities\n   - How data would be resolved\n3. Design an API gateway architecture for a microservices ecosystem\n4. Implement versioning, caching, and rate limiting strategies\n5. How would you handle authentication and authorization across multiple services?\n6. Discuss API documentation tools and best practices"
      },
      {
        "id": "q4",
        "question": "# Scalable Database Design\n\nExamine this diagram showing database scaling approaches:\n\n![Database Scaling](https://miro.medium.com/max/1400/1*atDD6tVrfxEpI93hR2TOgw.png)\n\nYou're designing a database system for a social media platform with these requirements:\n- 10 million active users\n- Users post content and follow each other\n- Heavy read operations (timeline generation)\n- Must support real-time notifications\n- Search functionality across all content\n- Analytics requirements\n\n1. Design a complete database architecture addressing:\n   - Choice of database types (SQL, NoSQL, time series, etc.)\n   - Sharding and partitioning strategy\n   - Replication approach\n   - Caching layers\n   - Read/write separation\n\n2. Explain how you would handle these specific challenges:\n   - Efficiently generating a user's timeline showing posts from followed users\n   - Implementing notifications when someone follows you or comments on your post\n   - Enabling fast full-text search\n   - Scaling as user count grows\n\n3. What monitoring and maintenance procedures would you establish?\n\n4. Discuss potential failure scenarios and recovery strategies"
      },
      {
        "id": "q5",
        "question": "# Modern Authentication Systems\n\nStudy this JWT-based authentication flow diagram:\n\n![JWT Authentication Flow](https://cdn2.auth0.com/docs/media/articles/api-auth/client-credentials-grant.png)\n\nImplement a complete authentication and authorization system for a modern application with these requirements:\n\n1. Support multiple authentication methods:\n   - Username/password\n   - Social login (Google, Facebook)\n   - Multi-factor authentication\n\n2. Implement role-based and resource-based authorization\n\n3. Address these security considerations:\n   - Password storage and management\n   - Token revocation\n   - Session management\n   - Protection against common attacks\n\n4. Implement secure API access for:\n   - Browser-based applications\n   - Mobile applications\n   - Server-to-server communication\n\n5. How would you handle user consent and privacy requirements?\n\n6. Compare different authentication providers and solutions (Auth0, Cognito, Firebase, custom solutions)"
      }
    ]
  }